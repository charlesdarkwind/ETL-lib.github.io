<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ETL Library: ETL.delta_utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ETL Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_e_t_l.html">ETL</a></li><li class="navelem"><a class="el" href="namespace_e_t_l_1_1delta__utils.html">delta_utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ETL.delta_utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5cf1b5612a590fbe4f02916a63d697b0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_t_l_1_1delta__utils.html#a5cf1b5612a590fbe4f02916a63d697b0">read</a> (config, zone, path, **dataframe_reader_options)</td></tr>
<tr class="separator:a5cf1b5612a590fbe4f02916a63d697b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59422ad9868d11300dedcaa864d69ff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_t_l_1_1delta__utils.html#ac59422ad9868d11300dedcaa864d69ff">write</a> (config, df, zone, path, table, **dataframe_writer_options)</td></tr>
<tr class="separator:ac59422ad9868d11300dedcaa864d69ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5382c97de7abcc49f5cf213f91656d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_t_l_1_1delta__utils.html#a1b5382c97de7abcc49f5cf213f91656d">merge</a> (config, zone, table, df, path, unique_key)</td></tr>
<tr class="separator:a1b5382c97de7abcc49f5cf213f91656d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253eb0d98f838d9755b7803ad35bcea5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_t_l_1_1delta__utils.html#a253eb0d98f838d9755b7803ad35bcea5">delete</a> (config, zone, table, path, database_name=None, drop=False)</td></tr>
<tr class="separator:a253eb0d98f838d9755b7803ad35bcea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9d968e0b6380d808e5bd498cdf9837"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_t_l_1_1delta__utils.html#acf9d968e0b6380d808e5bd498cdf9837">create_if_not_exists</a> (config, table, schema, location=None)</td></tr>
<tr class="separator:acf9d968e0b6380d808e5bd498cdf9837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45cecd95ec0561f4bc59089cabf8fba"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_t_l_1_1delta__utils.html#ac45cecd95ec0561f4bc59089cabf8fba">refresh_symlink</a> (path)</td></tr>
<tr class="separator:ac45cecd95ec0561f4bc59089cabf8fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a413a07e5b8d1ff17f754fee83afdb6ff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_e_t_l_1_1delta__utils.html#a413a07e5b8d1ff17f754fee83afdb6ff">upsert</a> = <a class="el" href="namespace_e_t_l_1_1delta__utils.html#a1b5382c97de7abcc49f5cf213f91656d">merge</a></td></tr>
<tr class="separator:a413a07e5b8d1ff17f754fee83afdb6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">This module provides utility functions to select, insert and delete operations on delta tables.

The names and structure of tables, folders and paths do not have to conform to the library's standard convention.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="acf9d968e0b6380d808e5bd498cdf9837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9d968e0b6380d808e5bd498cdf9837">&#9670;&nbsp;</a></span>create_if_not_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ETL.delta_utils.create_if_not_exists </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>location</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create table if not exists using data's schema

Parameters
----------
config: ETL.Config
  Config instance
table: str
  Table's registered name in the metastore
location: str, optional
schema: pyspark.sql.types.StructType
</pre> 
</div>
</div>
<a id="a253eb0d98f838d9755b7803ad35bcea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253eb0d98f838d9755b7803ad35bcea5">&#9670;&nbsp;</a></span>delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ETL.delta_utils.delete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>database_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>drop</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Delete delta data.

Only use drop when really needed, otherwise just overwrite or delete.

Parameters
----------
config: ETL.Config
  Config instance
zone: str
  Zone containing the tables to test.
table
path: str
database_name: str, optional
  Defaults to config.data_source
drop: bool, optional
  Drop table
</pre> 
</div>
</div>
<a id="a1b5382c97de7abcc49f5cf213f91656d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5382c97de7abcc49f5cf213f91656d">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ETL.delta_utils.merge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unique_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Update data in the delta table.

Performs a 'merge into'/'upsert' of a dataframe/table-view inside the Delata Table.
Meaning rows are overwritten if it finds one with the same designated unqique fields, or else it is inserted.
The batch of updates must not contain more than one row with the same chosen unique key.

Handles the creation of the SQL condition update part. Needs an unique key, can be a combination of 2 or more fields.
Eg. "ON delta_messages.message_id = updates.message_id AND delta_messages.id = updates.id"

Parameters
----------
config: ETL.Config
  Config instance
zone: str
table: str
path: str
df: pyspark.sql.DataFrame
  Dataframe containing the data to save in the curated delta table.
unique_key: list or str
  Columns with unique values or list of columns to use as a combined unique key.
</pre> 
</div>
</div>
<a id="a5cf1b5612a590fbe4f02916a63d697b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf1b5612a590fbe4f02916a63d697b0">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ETL.delta_utils.read </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>dataframe_reader_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read all data, equivalent of doing a "SELECT *"

Returns None if no data at path or path does not exists.
Can still return a empty dataframe or a dataframe of empty rows if such is obtained from reading the files.

Parameters
----------
config: ETL.Config
zone: str
path: str
dataframe_reader_options: dict

Returns
-------
pyspark.sql.DataFrame
</pre> 
</div>
</div>
<a id="ac45cecd95ec0561f4bc59089cabf8fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45cecd95ec0561f4bc59089cabf8fba">&#9670;&nbsp;</a></span>refresh_symlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ETL.delta_utils.refresh_symlink </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read a delta table at location to refresh the symlinks with the current secret.

Databricks 6.1 runtime might be introducing a way to avoid this with its new python APIs for the delta.tables module.

Unfortunatly, delta tables pointing to adls must be read with the spark api first to make them available again
following a daily secret renewal. Since a table could be used at any time, this should be done before anything I/O related.

This process typically involves some implicit reading logic using the SQL api when writing granuarly to a delta table (Eg. merge/upsert).
(when spark append/write cant be used) It will fail if the databrick secret is not the same that at creation.

Parameters
----------
  path: str
</pre> 
</div>
</div>
<a id="ac59422ad9868d11300dedcaa864d69ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59422ad9868d11300dedcaa864d69ff">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ETL.delta_utils.write </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>dataframe_writer_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Write/save data in the delta table(s).

todo allow usage withouge needing to create tables

Parameters
----------
config: ETL.Config
  Config instance
df: pyspark.sql.DataFrame
  Dataframe containing the data to save in the curated delta table.
zone: str
path: str
table: str, optional
  Defaults to path if None
dataframe_writer_options: dict
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a413a07e5b8d1ff17f754fee83afdb6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413a07e5b8d1ff17f754fee83afdb6ff">&#9670;&nbsp;</a></span>upsert</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ETL.delta_utils.upsert = <a class="el" href="namespace_e_t_l_1_1delta__utils.html#a1b5382c97de7abcc49f5cf213f91656d">merge</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
